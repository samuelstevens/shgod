>>>> AGENTS.md
# Code Style

- Keep code simple, explicit, typed, test-driven, and ready for automation.
- Source files are UTF-8 but must contain only ASCII characters. Do not use smart quotes, ellipses, em-dashes, emoji, or other non-ASCII glyphs.
- Docstrings are a single unwrapped paragraph. Rely on your editor's soft-wrap.
- Prefer explicit over implicit constructs. No wildcard imports.

```python
from . import tmux  # instead of from .tmux import Pane
```

Always reference modules by their alias. Never use `from X import *`.

- Decorate every public function or class with `@beartype.beartype`.
- Use frozen `@dataclasses.dataclass` for data containers such as `Config` or `Args`.
- Classes use `CamelCase`, for example `Dataset` or `FeatureExtractor`.
- Functions and variables use `snake_case`, for example `download_split` or `md5_of_file`.
- Constants are `UPPER_SNAKE`, defined at module top, for example `URLS = {...}`.
- File descriptors end in `fd`, for example `log_fd`.
- File paths end in `_fpath`; directories end in `_dpath`.
- Constructors follow verb prefixes:
  - `make_...` returns an object.
  - `get_...` returns a primitive value such as a string or path.
  - `setup_...` performs side effects and returns nothing.

# Testing

- Use pytest with fixtures and parameterization.
- Use Hypothesis for property-based tests, especially in helpers.

>>>> README.md
## Example Usage

```sh
shgod how do I check where OPENROUTER_API_KEY came from in fish?
```


```sh
shgod "can you explain what -a and -F are in tmux list-panes?"
```

>>>> __init__.py

>>>> __main__.py
if __name__ == "__main__":
    from . import cli

    cli.main()

>>>> cli.py
import dataclasses

import beartype
import tyro

from . import tmux


@beartype.beartype
@dataclasses.dataclass(frozen=True)
class Query:
    msg: str


@beartype.beartype
@dataclasses.dataclass(frozen=True)
class Context:
    pane: tmux.Pane
    other_panes: tuple[tmux.Pane, ...]

    def __init__(self):
        pane, others = tmux.get_panes()
        object.__setattr__(self, "pane", pane)
        object.__setattr__(self, "other_panes", others)


@beartype.beartype
def ask(words: list[str], /):
    """
    Ask an LLM for help with shell commands.

    Args:
        words: Your query.
    """
    ctx = Context()
    breakpoint()


def main():
    tyro.cli(ask)

>>>> prompt.j2
<assistant>
You are **shgod**, a terse yet precise terminal guru.  
Think, plan and act autonomously until the task is solved, then yield a final answer for the user.
</assistant>

<persistence>
Keep the conversation open; do **not** finish until the user’s request is fully satisfied.
</persistence>

<tool_calling>
If you’re missing information, call a tool instead of hallucinating.  
Prefer **one tool call → reflect → next tool**; avoid blind chains.
</tool_calling>

<planning>
Before each tool call:  
1 Write a short markdown bullet-list plan.  
2 State *why* the selected tool is needed.  
After each call: reflect on the output and decide next action.
</planning>

<tools>
<tool name="rgrep" description="Recursively grep for PATTERN under DIR. Output format: file:line:match"/>
<tool name="view"  description="Print file or directory snippets. Args: path, start_line, end_line"/>
<tool name="create" description="Create a new file with given content"/>
<tool name="insert" description="Insert text at line N of a file"/>
<tool name="str_replace" description="Sed-like in-place substitution on a file"/>
</tools>

<response_format>
1. **If planning** – markdown checklist inside `<plan>` … `</plan>`.  
2. **Tool calls** – valid JSON exactly as required by the completions.  
3. **Reflections / final answer** – plain markdown; commands in fenced ```bash blocks.
</response_format>

<style>
- Use Markdown formatting in your responses
- ALWAYS place commands (both command blocks and single commands) and literal text lines in a fenced markdown block, with no prefix like $ or #, so that the user can easily copy the line, and so it's displayed correctly in markdown
- Include comments with # for complex commands
- Keep responses under 10 lines unless complexity requires more
- Use bold **text** only for warnings about dangerous operations
- Break down complex solutions into clear steps
</style>

<important>
Always warn before any command that writes or deletes.
Flag actions needing sudo.
If you can't solve, ask a clarifying question; never invent data.
</important>

<environment>
<system>{{ system_info }}</system>
<cwd>{{ active_pane.cwd }}</cwd>
</environment>

<terminal_history>
<active_pane id="{{ active_pane.id }}">
{{ active_pane.history }}
</active_pane>
<other_panes>
{% for pane in panes if not pane.active %}
<pane id="{{ pane.id }}">
{{ pane.history }}
</pane>
{% endfor %}
</other_panes>
</terminal_history>

<query>
{{ user_query }}
</query>

>>>> templating.py
"""
Lightweight Jinja2 alternative.

* *literal text*: everything not inside tags (unchanged)
* *variable*: `{{ expr }}` (any valid Python eval in the provided context; output str(expr))
* *for loops*: `{% for x in seq %} ... {% endfor %}` (nested allowed)
* *if/elif/else*: `{% if cond %} ... {% elif cond2 %} ... {% else %} ... {% endif %}` (nested allowed)
* *comment*: `{# ... #}` (discarded)
* *escaping*: `{{{` renders `{{`; raw block not supported
"""

import beartype


@beartype.beartype
class Template:
    def __init__(self, path_or_str: str): ...

    def render(self, **kwargs) -> str: ...

>>>> test_templating.py
import pytest
from .templating import Template


# literals


def test_literal_passthrough():
    src = "no tags here"
    assert Template(src).render() == "no tags here"


# variables


def test_variable_simple():
    out = Template("hello {{ name }}!").render(name="bob")
    assert out == "hello bob!"


def test_variable_expr_whitespace():
    src = "{{ 1 + 1 }}"
    assert Template(src).render() == "2"


def test_variable_undefined_raises():
    with pytest.raises(NameError):
        Template("{{ missing }}").render()


# comments


def test_comment_stripped():
    src = "a{# noisy #}b"
    assert Template(src).render() == "ab"


# escaping


def test_escape_triple_brace():
    src = "{{{ not_a_tag }}"
    assert Template(src).render() == "{{ not_a_tag }}"


# for-loops


def test_for_loop_basic():
    tpl = "{% for x in seq %}[{{ x }}]{% endfor %}"
    assert Template(tpl).render(seq=[1, 2, 3]) == "[1][2][3]"


def test_for_loop_nested_shadow():
    tpl = "{% for x in outer %}{% for x in inner %}{{ x }}{% endfor %}{% endfor %}"
    assert Template(tpl).render(outer=[0, 1], inner=["a"]) == "aa"


# if / elif / else


def test_if_true_branch():
    tpl = "{% if ok %}yes{% else %}no{% endif %}"
    assert Template(tpl).render(ok=True) == "yes"


def test_if_false_no_else():
    tpl = "{% if ok %}yes{% endif %}done"
    assert Template(tpl).render(ok=False) == "done"


def test_if_elif_else_chain():
    tpl = "{% if n==0 %}zero{% elif n==1 %}one{% else %}many{% endif %}"
    assert Template(tpl).render(n=7) == "many"

>>>> tmux.py
import dataclasses
import subprocess

import beartype


@beartype.beartype
@dataclasses.dataclass(frozen=True)
class Pane:
    """Represents a tmux pane.

    A tmux pane is a rectangular section of a tmux window where commands
    can be executed.

    Attributes:
        id: The unique identifier of the pane.
        cwd: The current working directory of the pane.
        active: Whether the pane is currently active.
        history: All lines of history in the pane.
    """

    id: str
    cwd: str
    active: bool
    history: tuple[str, ...]


def get_panes() -> tuple[Pane, tuple[Pane, ...]]:
    front, others = None, []
    fmt = "#{pane_id},#{pane_active},#{pane_current_path}"
    cmd = [
        "tmux",
        "list-panes",
        "-a",  # all sessions
        "-F",  # custom format
        fmt,
    ]
    for line in subprocess.check_output(cmd, text=True).splitlines():
        pane_id, active, cwd = line.split(",", 2)

        hist_cmd = [
            "tmux",
            "capture-pane",
            "-p",  # print to stdout
            "-J",  # join wrapped lines
            "-S",
            "-100",  # start 100 lines from bottom
            "-t",  # target this pane
            pane_id,
        ]
        history = tuple(subprocess.check_output(hist_cmd, text=True).splitlines())

        pane = Pane(id=pane_id, cwd=cwd, active=active == "1", history=history)
        if pane.active:
            front = pane
        else:
            others.append(pane)

    return front, tuple(others)

